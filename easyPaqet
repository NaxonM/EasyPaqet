#!/usr/bin/env bash
set -euo pipefail

SCRIPT_NAME="$(basename "$0")"
ROLE=""
ACTION=""
PACKAGE_URL=""
CONFIG_PATH="/root/paqet-hub/config.yaml"
SERVICE_PATH="/etc/systemd/system/paqet.service"
PORT="444"
SOCKS_PORT="1080"
IFACE=""
LOCAL_IP=""
ROUTER_MAC=""
PEER_IP=""
KCP_KEY=""
MTU=""
APPLY_TUNING="false"
NO_DOWNLOAD="false"
LOCAL_ARCHIVE=""
DOWNLOAD_TIMEOUT="0"
CHECKSUM=""
LOG_LINES="100"
INTERACTIVE="false"
RUN_CONFIG_AFTER_INSTALL="false"
APPLY_FIREWALL_AFTER_CONFIG="false"
START_SERVICE_AFTER_CONFIG="false"
RUN_TEST_AFTER_CONFIG="false"
PURGE="false"
USE_COLOR="true"
CLEAR_SCREEN="true"
SKIP_RUN_ACTION="false"

init_colors() {
  if [ "$USE_COLOR" != "true" ] || [ -n "${NO_COLOR:-}" ] || [ ! -t 1 ]; then
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    CYAN=""
    BOLD=""
    NC=""
    return
  fi
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  CYAN='\033[0;36m'
  BOLD='\033[1m'
  NC='\033[0m'
}

info() {
  echo -e "${CYAN}[paqet]${NC} $*"
}

success() {
  echo -e "${GREEN}[OK]${NC} $*"
}

warn() {
  echo -e "${YELLOW}[WARN]${NC} $*"
}

error() {
  echo -e "${RED}[ERR]${NC} $*" >&2
}

show_status_badge() {
  local bin_path="/root/paqet-hub/paqet_linux_amd64"
  local installed="no"
  local running="no"
  local version="not installed"

  if [ -x "$bin_path" ]; then
    installed="yes"
    version="$(get_paqet_version)"
    if [ -z "$version" ]; then
      version="unknown"
    fi
  fi

  if systemctl is-active --quiet paqet 2>/dev/null; then
    running="yes"
  fi

  local installed_label
  local running_label
  if [ "$installed" = "yes" ]; then
    installed_label="${GREEN}yes${NC}"
  else
    installed_label="${RED}no${NC}"
  fi
  if [ "$running" = "yes" ]; then
    running_label="${GREEN}running${NC}"
  else
    running_label="${RED}stopped${NC}"
  fi
  echo -e "${BOLD}+--------------------------------------+${NC}"
  echo -e "${BOLD}|           easyPaqet Status           |${NC}"
  echo -e "${BOLD}+--------------------------------------+${NC}"
  echo -e "| Installed: $installed_label"
  echo -e "| Status:    $running_label"
  echo -e "| Version:   ${CYAN}$version${NC}"
  echo -e "${BOLD}+--------------------------------------+${NC}"
}

prompt() {
  local label="$1"
  local default_value="$2"
  local value=""
  if [ -n "$default_value" ]; then
    read -r -p "$label [$default_value]: " value
    echo "${value:-$default_value}"
  else
    read -r -p "$label: " value
    echo "$value"
  fi
}

usage() {
  cat <<EOF
Usage:
  $SCRIPT_NAME <action> [options]
  $SCRIPT_NAME            # interactive menu

Actions:
  quick-install   Guided install flow
  install         Download/extract package, install service, enable it
  update-binary   Update paqet binary from GitHub (keeps config)
  configure       Update config values for the selected role
  start|stop|restart|status
  logs            Follow service logs (journalctl)
  test            Test connection (client only)
  firewall-apply  Add iptables rules (server only)
  firewall-clean  Remove iptables rules (server only)
  view-config     Show current config
  backup-config   Backup current config
  uninstall       Disable service and remove files

Options:
  --role client|server   Required for install/configure (client=Iran, server=Kharej)
  --local-archive PATH   Use local tar.gz instead of downloading
  --package-url URL      Override package URL for install
  --checksum VALUE       Verify sha256/sha512 of archive (64 or 128 hex)
  --no-download          Skip download/extract (use existing /root/paqet-hub)
  --purge                Remove easyPaqet script and tuning file
  --download-timeout SEC Max seconds per download attempt (0 disables)
  --iface IFACE          Network interface name (default: auto-detect)
  --local-ip IP          Local server IP (default: auto-detect)
  --router-mac MAC       Router MAC (default: auto-detect)
  --peer-ip IP           Peer/server IP (client only)
  --port PORT            Listen/peer port (default: 444)
  --socks-port PORT      Socks5 listen port (client only, default: 1080)
  --kcp-key KEY          KCP key (optional)
  --mtu MTU              KCP MTU (optional)
  --apply-tuning         Apply sysctl and txqueuelen tuning
  --config-path PATH     Override config path
  --service-path PATH    Override systemd service path
  --log-lines N          Number of log lines for logs action (default: 100)

Examples:
  $SCRIPT_NAME quick-install
  $SCRIPT_NAME install --role server
  $SCRIPT_NAME configure --role server --iface eth0 --local-ip 5.1.2.3 --router-mac aa:bb:cc:dd:ee:ff
  $SCRIPT_NAME configure --role client --peer-ip 5.1.2.3
  $SCRIPT_NAME restart
  $SCRIPT_NAME firewall-apply --role server --port 444
  $SCRIPT_NAME firewall-clean --role server --port 444
  $SCRIPT_NAME test
  $SCRIPT_NAME view-config
  $SCRIPT_NAME backup-config
EOF
}

die() {
  echo "" >&2
  error "$*"
  echo "" >&2
  echo -e "${BOLD}Troubleshooting:${NC}" >&2
  case "$*" in
    *"download"*)
      echo "  - Check your internet connection" >&2
      echo "  - Try --local-archive with a local file" >&2
      echo "  - Verify the package URL is correct" >&2
      ;;
    *"checksum"*)
      echo "  - The downloaded file may be corrupted" >&2
      echo "  - Try downloading again" >&2
      echo "  - Verify the checksum value is correct" >&2
      ;;
    *"interface"*)
      echo "  - List interfaces: ip link show" >&2
      echo "  - Use --iface to specify manually" >&2
      ;;
    *"KCP key"*)
      echo "  - Server: key is auto-generated during configuration" >&2
      echo "  - Client: paste the key from the server" >&2
      echo "  - Key must be 32-128 characters, no spaces or quotes" >&2
      ;;
  esac
  echo "" >&2
  echo -e "${CYAN}Need help? Visit: t.me/evilcu${NC}" >&2
  exit 1
}

require_root() {
  if [ "$(id -u)" -ne 0 ]; then
    die "Run as root."
  fi
}

parse_args() {
  if [ "$#" -lt 1 ]; then
    INTERACTIVE="true"
    return
  fi

  ACTION="$1"
  shift

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --role)
        ROLE="$2"; shift 2 ;;
      --package-url)
        PACKAGE_URL="$2"; shift 2 ;;
      --local-archive)
        LOCAL_ARCHIVE="$2"; shift 2 ;;
      --no-download)
        NO_DOWNLOAD="true"; shift ;;
      --purge)
        PURGE="true"; shift ;;
      --iface)
        IFACE="$2"; shift 2 ;;
      --local-ip)
        LOCAL_IP="$2"; shift 2 ;;
      --router-mac)
        ROUTER_MAC="$2"; shift 2 ;;
      --peer-ip)
        PEER_IP="$2"; shift 2 ;;
      --port)
        PORT="$2"; shift 2 ;;
      --socks-port)
        SOCKS_PORT="$2"; shift 2 ;;
      --kcp-key)
        KCP_KEY="$2"; shift 2 ;;
      --mtu)
        MTU="$2"; shift 2 ;;
      --apply-tuning)
        APPLY_TUNING="true"; shift ;;
      --config-path)
        CONFIG_PATH="$2"; shift 2 ;;
      --service-path)
        SERVICE_PATH="$2"; shift 2 ;;
      --download-timeout)
        DOWNLOAD_TIMEOUT="$2"; shift 2 ;;
      --checksum)
        CHECKSUM="$2"; shift 2 ;;
      --log-lines)
        LOG_LINES="$2"; shift 2 ;;
      -h|--help)
        usage; exit 0 ;;
      *)
        die "Unknown option: $1" ;;
    esac
  done
}

normalize_role() {
  if [ -z "$ROLE" ]; then
    return
  fi
  local normalized
  normalized="$(printf "%s" "$ROLE" | tr '[:upper:]' '[:lower:]')"
  case "$normalized" in
    iran)
      ROLE="client" ;;
    kharej)
      ROLE="server" ;;
    client|server)
      ROLE="$normalized" ;;
  esac
}

is_valid_ip() {
  local ip="$1"
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  local o1 o2 o3 o4
  IFS='.' read -r o1 o2 o3 o4 <<< "$ip"
  for o in "$o1" "$o2" "$o3" "$o4"; do
    if ! [[ "$o" =~ ^[0-9]+$ ]] || [ "$o" -gt 255 ]; then
      return 1
    fi
  done
  return 0
}

is_valid_mac() {
  [[ "$1" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]]
}

is_valid_port() {
  [[ "$1" =~ ^[0-9]+$ ]] || return 1
  [ "$1" -ge 1 ] && [ "$1" -le 65535 ]
}

is_valid_mtu() {
  [[ "$1" =~ ^[0-9]+$ ]] || return 1
  [ "$1" -ge 68 ] && [ "$1" -le 9000 ]
}

is_valid_kcp_key() {
  local key="$1"
  local len
  len="${#key}"
  if [ "$len" -lt 32 ] || [ "$len" -gt 128 ]; then
    return 1
  fi
  if [[ "$key" =~ [[:space:]\\"] ]]; then
    return 1
  fi
  return 0
}

validate_config_values() {
  [ -n "$IFACE" ] || die "Interface is required."
  is_valid_ip "$LOCAL_IP" || die "Invalid local IP."
  is_valid_mac "$ROUTER_MAC" || die "Invalid router MAC."
  is_valid_port "$PORT" || die "Invalid port."
  if [ -n "$MTU" ]; then
    is_valid_mtu "$MTU" || die "Invalid MTU (68-9000)."
  fi
  if [ -z "$KCP_KEY" ]; then
    if [ "$ROLE" = "server" ]; then
      KCP_KEY="$(generate_kcp_key)"
      info "Generated KCP key for server: $KCP_KEY"
    else
      die "KCP key is required for client. Get it from the server."
    fi
  fi
  is_valid_kcp_key "$KCP_KEY" || die "Invalid KCP key (32-128 chars, no spaces or quotes)."
  if [ "$ROLE" = "client" ]; then
    [ -n "$PEER_IP" ] || die "Peer (server) IP is required for client."
    is_valid_ip "$PEER_IP" || die "Invalid peer (server) IP."
    is_valid_port "$SOCKS_PORT" || die "Invalid socks port."
  fi
}

print_config_summary() {
  echo "Configuration summary:"
  echo "  role: $ROLE"
  echo "  interface: $IFACE"
  echo "  local ip: $LOCAL_IP"
  echo "  router mac: $ROUTER_MAC"
  echo "  port: $PORT"
  if [ "$ROLE" = "client" ]; then
    echo "  peer ip: $PEER_IP"
    echo "  socks port: $SOCKS_PORT"
  fi
  echo "  apply tuning: $APPLY_TUNING"
  local version
  version="$(get_paqet_version)"
  if [ -n "$version" ]; then
    echo "  binary version: $version"
  else
    echo "  binary version: not installed"
  fi
}

confirm_config() {
  local answer
  answer="$(prompt_yes_no "Proceed with these settings? (yes/no)" "yes")"
  [ "$answer" = "yes" ]
}

collect_config_prompts() {
  local auto_iface
  auto_iface="$(ip route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") print $(i+1)}' | head -n1)"
  while :; do
    if [ -n "$auto_iface" ]; then
      IFACE="$(prompt "Interface" "$auto_iface")"
    else
      IFACE="$(prompt "Interface" "")"
    fi
    if [ -n "$IFACE" ]; then
      break
    fi
    echo "Interface is required."
  done

  local detected_ip
  detected_ip="$(ip -4 addr show dev "${IFACE:-}" 2>/dev/null | awk '/inet / {print $2}' | head -n1 | cut -d/ -f1)"
  while :; do
    if [ -n "$detected_ip" ]; then
      LOCAL_IP="$(prompt "Local IP" "$detected_ip")"
    else
      LOCAL_IP="$(prompt "Local IP" "")"
    fi
    if is_valid_ip "$LOCAL_IP"; then
      break
    fi
    echo "Invalid local IP."
  done

  local gw detected_mac
  gw="$(ip route show default 2>/dev/null | awk '{print $3}' | head -n1)"
  detected_mac="$(ip neigh show "$gw" 2>/dev/null | awk '{print $5; exit}')"
  while :; do
    if [ -n "$detected_mac" ]; then
      ROUTER_MAC="$(prompt "Router MAC" "$detected_mac")"
    else
      ROUTER_MAC="$(prompt "Router MAC" "")"
    fi
    if is_valid_mac "$ROUTER_MAC"; then
      break
    fi
    echo "Invalid router MAC."
  done

  while :; do
    PORT="$(prompt "Port" "$PORT")"
    if is_valid_port "$PORT"; then
      break
    fi
    echo "Invalid port."
  done

  while :; do
    MTU="$(prompt "MTU (empty to use default)" "${MTU:-}")"
    if [ -z "$MTU" ] || is_valid_mtu "$MTU"; then
      break
    fi
    echo "Invalid MTU (68-9000)."
  done

  if [ "$ROLE" = "server" ]; then
    KCP_KEY="$(prompt "KCP key (empty to generate)" "")"
    if [ -z "$KCP_KEY" ]; then
      KCP_KEY="$(generate_kcp_key)"
      info "Generated KCP key for server: $KCP_KEY"
    fi
  else
    while :; do
      KCP_KEY="$(prompt "KCP key (from server)" "")"
      if is_valid_kcp_key "$KCP_KEY"; then
        break
      fi
      echo "Invalid KCP key (32-128 chars, no spaces or quotes)."
    done
  fi

  if [ "$ROLE" = "client" ]; then
    while :; do
      PEER_IP="$(prompt "Peer (server) IP" "")"
      if is_valid_ip "$PEER_IP"; then
        break
      fi
      echo "Peer (server) IP is required and must be valid."
    done
    while :; do
      SOCKS_PORT="$(prompt "Socks5 port" "$SOCKS_PORT")"
      if is_valid_port "$SOCKS_PORT"; then
        break
      fi
      echo "Invalid socks port."
    done
  fi

  local tuning_choice
  tuning_choice="$(prompt_yes_no "Apply tuning? (yes/no)" "no")"
  if [ "$tuning_choice" = "yes" ]; then
    APPLY_TUNING="true"
  fi
}

prompt_config_flow() {
  while :; do
    collect_config_prompts
    validate_config_values
    print_config_summary
    if confirm_config; then
      break
    fi
    local retry
    retry="$(prompt_yes_no "Re-enter values? (yes/no)" "yes")"
    if [ "$retry" != "yes" ]; then
      die "Cancelled by user."
    fi
  done
}

prompt_yes_no() {
  local label="$1"
  local default_value="$2"
  local value=""
  while :; do
    value="$(prompt "$label" "$default_value")"
    case "$(printf "%s" "$value" | tr '[:upper:]' '[:lower:]')" in
      yes|y)
        echo "yes"; return 0 ;;
      no|n)
        echo "no"; return 0 ;;
    esac
    echo "Please answer yes or no."
  done
}

prompt_archive_path() {
  local path
  while :; do
    path="$(prompt "Local archive path (empty to download)" "")"
    if [ -z "$path" ]; then
      echo ""
      return 0
    fi
    if [ -f "$path" ]; then
      echo "$path"
      return 0
    fi
    echo "Archive not found: $path" >&2
  done
}

prompt_download_timeout() {
  local value
  while :; do
    value="$(prompt "Download timeout seconds (0 for no timeout)" "$DOWNLOAD_TIMEOUT")"
    if [[ "$value" =~ ^[0-9]+$ ]]; then
      DOWNLOAD_TIMEOUT="$value"
      return 0
    fi
    echo "Timeout must be a number."
  done
}

prompt_checksum() {
  local value
  value="$(prompt "Expected checksum (sha256/sha512, empty to skip)" "")"
  CHECKSUM="$value"
}

reset_menu_state() {
  ROLE=""
  ACTION=""
  PACKAGE_URL=""
  IFACE=""
  LOCAL_IP=""
  ROUTER_MAC=""
  PEER_IP=""
  KCP_KEY=""
  MTU=""
  APPLY_TUNING="false"
  NO_DOWNLOAD="false"
  LOCAL_ARCHIVE=""
  RUN_CONFIG_AFTER_INSTALL="false"
  APPLY_FIREWALL_AFTER_CONFIG="false"
  START_SERVICE_AFTER_CONFIG="false"
  RUN_TEST_AFTER_CONFIG="false"
  PURGE="false"
  SKIP_RUN_ACTION="false"
}

show_navigation_help() {
  echo -e "${BOLD}Navigation:${NC}"
  echo "  - Enter number and press Enter"
  echo "  - Type 'help' for usage"
  echo "  - Ctrl+C to cancel"
  echo ""
}

quick_install_guided() {
  echo -e "${BOLD}Quick Install - Step by Step${NC}"

  if [ -z "$ROLE" ]; then
    local role_num
    role_num="$(prompt "Select role (1=server/Kharej, 2=client/Iran)" "1")"
    case "$role_num" in
      1) ROLE="server" ;;
      2) ROLE="client" ;;
      *) die "Invalid role selection." ;;
    esac
  fi

  echo -e "${BOLD}Choose installation method${NC}"
  echo "  1) Download from GitHub"
  echo "  2) Use local archive"
  echo "  3) Skip download (already installed)"
  local method
  method="$(prompt "Select" "1")"
  case "$method" in
    1)
      NO_DOWNLOAD="false"
      LOCAL_ARCHIVE=""
      prompt_download_timeout
      prompt_checksum
      ;;
    2)
      LOCAL_ARCHIVE="$(prompt_archive_path)"
      [ -n "$LOCAL_ARCHIVE" ] || die "Local archive is required."
      NO_DOWNLOAD="true"
      ;;
    3)
      NO_DOWNLOAD="true"
      ;;
    *) die "Invalid selection." ;;
  esac

  RUN_CONFIG_AFTER_INSTALL="true"
  prompt_config_flow

  ACTION="install"
  run_action
}

interactive_menu() {
  while :; do
    reset_menu_state
    if [ "$CLEAR_SCREEN" = "true" ] && command -v clear >/dev/null 2>&1; then
      clear
    fi
    show_status_badge
    echo -e "${BOLD}+--------------------------------------+${NC}"
    echo -e "${BOLD}|          easyPaqet Manager           |${NC}"
    echo -e "${BOLD}+--------------------------------------+${NC}"
    echo -e "${CYAN}Setup & Configuration${NC}"
    echo "  1) Quick Install (Guided)"
    echo "  2) Advanced Install"
    echo "  3) Reconfigure Settings"
    echo "  4) Update Binary"
    echo ""
    echo -e "${CYAN}Service Control${NC}"
    echo "  5) Start Service"
    echo "  6) Stop Service"
    echo "  7) Restart Service"
    echo "  8) View Status"
    echo "  9) View Logs"
    echo ""
    echo -e "${CYAN}Network & Security${NC}"
    echo " 10) Apply Firewall Rules"
    echo " 11) Remove Firewall Rules"
    echo " 12) Test Connection"
    echo ""
    echo -e "${CYAN}Maintenance${NC}"
    echo " 13) View Configuration"
    echo " 14) Backup Configuration"
    echo " 15) Uninstall"
    echo ""
    echo "  0) Quit"
    echo -e "${BOLD}+--------------------------------------+${NC}"
    show_navigation_help
    local choice
    choice="$(prompt "Select action" "1")"
    case "$choice" in
      1|qi|quick|quick-install) ACTION="quick-install" ;;
      2|i|install) ACTION="install" ;;
      3|c|config|configure) ACTION="configure" ;;
      4|u|update) ACTION="update-binary" ;;
      5|start) ACTION="start" ;;
      6|stop) ACTION="stop" ;;
      7|restart) ACTION="restart" ;;
      8|status) ACTION="status" ;;
      9|logs) ACTION="logs" ;;
      10|fa|firewall-apply) ACTION="firewall-apply" ;;
      11|fc|firewall-clean) ACTION="firewall-clean" ;;
      12|test) ACTION="test" ;;
      13|view|view-config) ACTION="view-config" ;;
      14|backup|backup-config) ACTION="backup-config" ;;
      15|uninstall) ACTION="uninstall" ;;
      0|q|quit|exit) return ;;
      help|h) usage; continue ;;
      *) die "Invalid selection." ;;
    esac

    if [ "$ACTION" = "install" ] || [ "$ACTION" = "quick-install" ] || [ "$ACTION" = "configure" ] || [ "$ACTION" = "firewall-apply" ] || [ "$ACTION" = "firewall-clean" ]; then
    local role_choice
    role_choice="$(prompt "Role (client=Iran / server=Kharej)" "server")"
    ROLE="$role_choice"
    normalize_role
    fi

    if [ "$ACTION" = "quick-install" ]; then
      quick_install_guided
      SKIP_RUN_ACTION="true"
    fi

    if [ "$ACTION" = "install" ]; then
    local local_archive_path
    local_archive_path="$(prompt_archive_path)"
    if [ -n "$local_archive_path" ]; then
      LOCAL_ARCHIVE="$local_archive_path"
      NO_DOWNLOAD="true"
    fi

    if [ -z "$LOCAL_ARCHIVE" ]; then
      local use_download
      use_download="$(prompt_yes_no "Download package? (yes/no)" "yes")"
      if [ "$use_download" != "yes" ]; then
        NO_DOWNLOAD="true"
      else
        prompt_download_timeout
        prompt_checksum
      fi
    fi

    local configure_now
    configure_now="$(prompt_yes_no "Configure now? (yes/no)" "yes")"
    if [ "$configure_now" = "yes" ]; then
      RUN_CONFIG_AFTER_INSTALL="true"
      prompt_config_flow
    fi

      # Post-config actions are prompted after install/configure completes.
    fi

    if [ "$ACTION" = "configure" ]; then
      normalize_role
      prompt_config_flow

      if [ "$ROLE" = "server" ]; then
        local apply_fw
        apply_fw="$(prompt_yes_no "Apply firewall rules now? (yes/no)" "no")"
        if [ "$apply_fw" = "yes" ]; then
          APPLY_FIREWALL_AFTER_CONFIG="true"
        fi
      fi

      local start_now
      start_now="$(prompt_yes_no "Start service now? (yes/no)" "no")"
      if [ "$start_now" = "yes" ]; then
        START_SERVICE_AFTER_CONFIG="true"
      fi

      if [ "$ROLE" = "client" ]; then
        local test_now
        test_now="$(prompt_yes_no "Test connection now? (yes/no)" "no")"
        if [ "$test_now" = "yes" ]; then
          RUN_TEST_AFTER_CONFIG="true"
        fi
      fi
    fi

    if [ "$ACTION" = "uninstall" ]; then
      local purge_now
      purge_now="$(prompt_yes_no "Remove easyPaqet script and tuning file? (yes/no)" "no")"
      if [ "$purge_now" = "yes" ]; then
        PURGE="true"
      fi
    fi

    if [ "$SKIP_RUN_ACTION" = "true" ]; then
      continue
    fi
    run_action

    local again
    again="$(prompt_yes_no "Back to menu? (yes/no)" "yes")"
    if [ "$again" != "yes" ]; then
      return
    fi
  done
}

detect_iface() {
  if [ -n "$IFACE" ]; then
    return
  fi
  IFACE="$(ip route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") print $(i+1)}' | head -n1)"
  if [ -z "$IFACE" ]; then
    die "Unable to detect default interface. Use --iface."
  fi
}

detect_local_ip() {
  if [ -n "$LOCAL_IP" ]; then
    return
  fi
  LOCAL_IP="$(ip -4 addr show dev "$IFACE" 2>/dev/null | awk '/inet / {print $2}' | head -n1 | cut -d/ -f1)"
  if [ -z "$LOCAL_IP" ]; then
    die "Unable to detect local IP. Use --local-ip."
  fi
}

detect_router_mac() {
  if [ -n "$ROUTER_MAC" ]; then
    return
  fi
  local gw
  gw="$(ip route show default 2>/dev/null | awk '{print $3}' | head -n1)"
  if [ -z "$gw" ]; then
    die "Unable to detect default gateway. Use --router-mac."
  fi
  ROUTER_MAC="$(ip neigh show "$gw" 2>/dev/null | awk '{print $5; exit}')"
  if [ -z "$ROUTER_MAC" ]; then
    ROUTER_MAC="$(arp -n "$gw" 2>/dev/null | awk 'NR==2 {print $3}')"
  fi
  if [ -z "$ROUTER_MAC" ]; then
    die "Unable to detect router MAC. Use --router-mac."
  fi
}

apply_tuning() {
  if [ "$APPLY_TUNING" != "true" ]; then
    return
  fi
  cat <<EOF > /etc/sysctl.d/99-max-performance.conf
net.core.netdev_max_backlog = 250000
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.core.rmem_default = 33554432
net.core.wmem_default = 33554432
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 30000
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.udp_mem = 65536 131072 262144
EOF
  sysctl --system
  ifconfig "$IFACE" txqueuelen 20000
}

ensure_package() {
  if [ "$NO_DOWNLOAD" = "true" ]; then
    if [ -n "$LOCAL_ARCHIVE" ]; then
      verify_checksum "$LOCAL_ARCHIVE" "$CHECKSUM"
      install_from_archive "$LOCAL_ARCHIVE"
      return
    fi
    if [ ! -d /root/paqet-hub ]; then
      die "No download selected, but /root/paqet-hub is missing. Provide --local-archive or allow download."
    fi
    return
  fi

  if [ -n "$LOCAL_ARCHIVE" ]; then
    verify_checksum "$LOCAL_ARCHIVE" "$CHECKSUM"
    install_from_archive "$LOCAL_ARCHIVE"
    return
  fi

  local tmp_dir
  tmp_dir="$(make_tmp_dir)"

  if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
    die "curl or wget is required for download."
  fi

  if ! download_from_github_latest "$tmp_dir"; then
    echo "GitHub download failed."
    if [ "$ROLE" = "client" ]; then
      echo "Offline installation is recommended to avoid version mismatch."
    fi
    if [ -n "$PACKAGE_URL" ]; then
      echo "Trying custom package URL."
    elif [ "$INTERACTIVE" = "true" ]; then
      local use_custom
      use_custom="$(prompt_yes_no "Provide a custom download URL? (yes/no)" "no")"
      if [ "$use_custom" = "yes" ]; then
        PACKAGE_URL="$(prompt "Custom package URL" "")"
      else
        local use_archive
        use_archive="$(prompt_yes_no "Use local archive instead? (yes/no)" "no")"
        if [ "$use_archive" = "yes" ]; then
          local archive_path
          archive_path="$(prompt_archive_path)"
          if [ -n "$archive_path" ]; then
            verify_checksum "$archive_path" "$CHECKSUM"
            install_from_archive "$archive_path"
            rm -rf "$tmp_dir"
            return
          fi
        fi
      fi
    else
      rm -rf "$tmp_dir"
      die "GitHub download failed. Provide --package-url or --local-archive."
    fi
    if [ -z "$PACKAGE_URL" ]; then
      rm -rf "$tmp_dir"
      die "Download cancelled. Provide --package-url or --local-archive."
    fi
    if ! download_to_dir "$PACKAGE_URL" "$tmp_dir"; then
      rm -rf "$tmp_dir"
      die "Download failed from GitHub and custom URL."
    fi
  fi

  local file_path
  file_path="$(ls -1 "$tmp_dir" | head -n1)"
  if [ -z "$file_path" ]; then
    rm -rf "$tmp_dir"
    die "Download failed."
  fi

  verify_checksum "$tmp_dir/$file_path" "$CHECKSUM"
  install_from_archive "$tmp_dir/$file_path"

  rm -rf "$tmp_dir"
}

download_to_dir() {
  local url="$1"
  local dir="$2"
  local out_file="$dir/package.tar.gz"
  local tmp_file="$dir/package.tar.gz.part"
  rm -f "$tmp_file"
  if command -v curl >/dev/null 2>&1; then
    local curl_args=("-fL" "--retry" "3" "--retry-delay" "2" "-o" "$tmp_file")
    if [ "$DOWNLOAD_TIMEOUT" != "0" ]; then
      curl_args+=("--max-time" "$DOWNLOAD_TIMEOUT")
    fi
    if ! curl "${curl_args[@]}" "$url"; then
      rm -f "$tmp_file"
      return 1
    fi
  else
    local wget_args=("-O" "$tmp_file")
    if [ "$DOWNLOAD_TIMEOUT" != "0" ]; then
      wget_args+=("--timeout=$DOWNLOAD_TIMEOUT")
    fi
    if ! wget "${wget_args[@]}" "$url"; then
      rm -f "$tmp_file"
      return 1
    fi
  fi
  if [ ! -s "$tmp_file" ]; then
    rm -f "$tmp_file"
    return 1
  fi
  mv "$tmp_file" "$out_file"
  return 0
}

download_from_github_latest() {
  local dir="$1"
  local arch
  arch="$(uname -m)"

  local asset=""
  case "$arch" in
    x86_64|amd64)
      asset="paqet-linux-amd64"
      ;;
    aarch64|arm64)
      asset="paqet-linux-arm64"
      ;;
    *)
      return 1
      ;;
  esac

  local api_url="https://api.github.com/repos/hanselime/paqet/releases/latest"
  local download_url=""

  if command -v curl >/dev/null 2>&1; then
    download_url="$(curl -fsSL "$api_url" | awk -F'"' -v asset="$asset" '
      /browser_download_url/ && $0 ~ asset && $0 ~ /\.tar\.gz/ {print $4; exit}
    ')"
  else
    download_url="$(wget -qO- "$api_url" | awk -F'"' -v asset="$asset" '
      /browser_download_url/ && $0 ~ asset && $0 ~ /\.tar\.gz/ {print $4; exit}
    ')"
  fi

  if [ -z "$download_url" ]; then
    return 1
  fi

  download_to_dir "$download_url" "$dir"
}

write_service() {
  cat <<EOF > "$SERVICE_PATH"
[Unit]
Description=Paqet Service ($ROLE)
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root/paqet-hub
ExecStart=/root/paqet-hub/paqet_linux_amd64 run -c $CONFIG_PATH
Restart=always
RestartSec=3
StartLimitBurst=0
LimitNOFILE=1000000

CPUSchedulingPolicy=fifo
CPUSchedulingPriority=99
Nice=-20

[Install]
WantedBy=multi-user.target
EOF
}

install_from_archive() {
  local archive_path="$1"
  [ -f "$archive_path" ] || die "Archive not found: $archive_path"

  local tmp_dir
  tmp_dir="$(mktemp -d)"
  local extract_dir
  extract_dir="$tmp_dir/extract"
  mkdir -p "$extract_dir"
  tar -xzvf "$archive_path" -C "$extract_dir"

  if [ -d "$extract_dir/root/paqet-hub" ]; then
    mkdir -p /root
    cp -a "$extract_dir/root/paqet-hub" /root/
  elif [ -d "$extract_dir/paqet-hub" ]; then
    mkdir -p /root
    cp -a "$extract_dir/paqet-hub" /root/
  else
    mkdir -p /root/paqet-hub
    if [ -f "$extract_dir/paqet_linux_amd64" ]; then
      cp -a "$extract_dir/paqet_linux_amd64" /root/paqet-hub/
    fi
    if [ -d "$extract_dir/example" ]; then
      cp -a "$extract_dir/example" /root/paqet-hub/
    fi
    if [ -f "$extract_dir/README.md" ]; then
      cp -a "$extract_dir/README.md" /root/paqet-hub/
    fi
  fi

  rm -rf "$tmp_dir"
}

get_paqet_version() {
  local bin_path="/root/paqet-hub/paqet_linux_amd64"
  if [ -x "$bin_path" ]; then
    "$bin_path" version 2>/dev/null | awk -F': ' '/^Version:/ {gsub(/^[ \t]+/, "", $2); print $2; exit}' || true
  fi
}

verify_checksum() {
  local file_path="$1"
  local checksum="$2"
  if [ -z "$checksum" ]; then
    return 0
  fi
  if ! [[ "$checksum" =~ ^[0-9A-Fa-f]+$ ]]; then
    die "Checksum must be hex."
  fi
  local checksum_len
  checksum_len="${#checksum}"
  if [ "$checksum_len" -eq 64 ]; then
    if command -v sha256sum >/dev/null 2>&1; then
      echo "${checksum}  ${file_path}" | sha256sum -c -
    elif command -v openssl >/dev/null 2>&1; then
      local actual
      actual="$(openssl dgst -sha256 "$file_path" | awk '{print $2}')"
      [ "${checksum,,}" = "${actual,,}" ]
    else
      die "sha256sum or openssl is required for checksum verification."
    fi
  elif [ "$checksum_len" -eq 128 ]; then
    if command -v sha512sum >/dev/null 2>&1; then
      echo "${checksum}  ${file_path}" | sha512sum -c -
    elif command -v openssl >/dev/null 2>&1; then
      local actual
      actual="$(openssl dgst -sha512 "$file_path" | awk '{print $2}')"
      [ "${checksum,,}" = "${actual,,}" ]
    else
      die "sha512sum or openssl is required for checksum verification."
    fi
  else
    die "Checksum must be 64 (sha256) or 128 (sha512) hex characters."
  fi
}

generate_kcp_key() {
  if command -v /root/paqet-hub/paqet_linux_amd64 >/dev/null 2>&1; then
    /root/paqet-hub/paqet_linux_amd64 secret 2>/dev/null | tr -d '\r\n'
    return 0
  fi
  if command -v openssl >/dev/null 2>&1; then
    openssl rand -base64 32 | tr -d '\r\n'
    return 0
  fi
  if command -v base64 >/dev/null 2>&1; then
    head -c 32 /dev/urandom | base64 | tr -d '\r\n'
    return 0
  fi
  die "Unable to generate KCP key (missing openssl/base64)."
}

make_tmp_dir() {
  local dir
  for dir in /tmp /var/tmp /root; do
    if [ -d "$dir" ] && [ -w "$dir" ]; then
      if tmp_dir="$(mktemp -d -p "$dir" 2>/dev/null)"; then
        echo "$tmp_dir"
        return 0
      fi
    fi
  done
  die "Unable to create a temporary directory."
}

update_binary_from_archive() {
  local archive_path="$1"
  [ -f "$archive_path" ] || die "Archive not found: $archive_path"

  local tmp_dir
  tmp_dir="$(mktemp -d)"
  local extract_dir
  extract_dir="$tmp_dir/extract"
  mkdir -p "$extract_dir"
  tar -xzvf "$archive_path" -C "$extract_dir"

  local src_bin
  if [ -f "$extract_dir/root/paqet-hub/paqet_linux_amd64" ]; then
    src_bin="$extract_dir/root/paqet-hub/paqet_linux_amd64"
  elif [ -f "$extract_dir/paqet_linux_amd64" ]; then
    src_bin="$extract_dir/paqet_linux_amd64"
  else
    src_bin="$(find "$extract_dir" -type f -name 'paqet_linux_amd64' | head -n1)"
  fi

  if [ -z "$src_bin" ]; then
    rm -rf "$tmp_dir"
    die "paqet_linux_amd64 not found in archive."
  fi

  mkdir -p /root/paqet-hub
  local dest_bin="/root/paqet-hub/paqet_linux_amd64"
  if [ -f "$dest_bin" ]; then
    mv "$dest_bin" "$dest_bin.bak.$(date +%Y%m%d%H%M%S)"
  fi
  cp -a "$src_bin" "$dest_bin"
  chmod +x "$dest_bin"

  rm -rf "$tmp_dir"
}

backup_config() {
  if [ -f "$CONFIG_PATH" ]; then
    cp "$CONFIG_PATH" "$CONFIG_PATH.bak.$(date +%Y%m%d%H%M%S)"
  fi
}

write_config_template() {
  if [ "$ROLE" = "client" ]; then
    cat <<EOF > "$CONFIG_PATH"
role: "client"
log:
  level: "error"
socks5:
  - listen: "127.0.0.1:$SOCKS_PORT"
network:
  interface: "$IFACE"
  ipv4:
    addr: "$LOCAL_IP:0"
    router_mac: "$ROUTER_MAC"
server:
  addr: "$PEER_IP:$PORT"
transport:
  protocol: "kcp"
  kcp:
    block: "none"
    key: "$KCP_KEY"
    mtu: ${MTU:-1350}
    sndwnd: 1024
    rcvwnd: 1024
    nodelay: 1
    interval: 10
    resend: 1
    nc: 1
EOF
  else
    cat <<EOF > "$CONFIG_PATH"
role: "server"
log:
  level: "error"
listen:
  addr: "0.0.0.0:$PORT"
network:
  interface: "$IFACE"
  ipv4:
    addr: "$LOCAL_IP:$PORT"
    router_mac: "$ROUTER_MAC"
transport:
  protocol: "kcp"
  kcp:
    block: "none"
    key: "$KCP_KEY"
    mtu: ${MTU:-1350}
    sndwnd: 1024
    rcvwnd: 1024
    nodelay: 1
    interval: 10
    resend: 1
    nc: 1
EOF
  fi
}

write_placeholder_config() {
  if [ "$ROLE" = "client" ]; then
    cat <<EOF > "$CONFIG_PATH"
role: "client"
log:
  level: "error"
socks5:
  - listen: "127.0.0.1:$SOCKS_PORT"
network:
  interface: "eth0"
  ipv4:
    addr: "0.0.0.0:0"
    router_mac: "00:00:00:00:00:00"
server:
  addr: "0.0.0.0:$PORT"
transport:
  protocol: "kcp"
  kcp:
    block: "none"
    key: "CHANGE_ME"
    mtu: ${MTU:-1350}
    sndwnd: 1024
    rcvwnd: 1024
    nodelay: 1
    interval: 10
    resend: 1
    nc: 1
EOF
  else
    cat <<EOF > "$CONFIG_PATH"
role: "server"
log:
  level: "error"
listen:
  addr: "0.0.0.0:$PORT"
network:
  interface: "eth0"
  ipv4:
    addr: "0.0.0.0:$PORT"
    router_mac: "00:00:00:00:00:00"
transport:
  protocol: "kcp"
  kcp:
    block: "none"
    key: "CHANGE_ME"
    mtu: ${MTU:-1350}
    sndwnd: 1024
    rcvwnd: 1024
    nodelay: 1
    interval: 10
    resend: 1
    nc: 1
EOF
  fi
}

write_evilcu_md() {
  local content=""
  if [ "$ROLE" = "client" ]; then
    content=$'داخل فایل کانفیگ آیپی های خودتون و اسم اینترفیس و مک آدرس سرور رو عوض کنید\n\nt.me/evilcu\nتوضیحات در چنل\n'
  else
    content=$'آیپی و اسم اینترفیس و مک آدرس رو ویرایش کنید \nt.me/evilcu\nتوضیحات در چنل\n'
  fi
  printf "%s" "$content" > /root/paqet-hub/evilcu.md
}

ensure_custom_files() {
  mkdir -p /root/paqet-hub
  if [ ! -f /root/paqet-hub/evilcu.md ]; then
    write_evilcu_md
  fi
  if [ ! -f "$CONFIG_PATH" ]; then
    write_placeholder_config
  fi
}

replace_line() {
  local pattern="$1"
  local replacement="$2"
  if grep -q "$pattern" "$CONFIG_PATH"; then
    sed -i "s|$pattern|$replacement|" "$CONFIG_PATH"
  fi
}

replace_addr_block() {
  local key="$1"
  local addr_value="$2"
  awk -v key="$key" -v addr="  addr: \"$addr_value\"" '
    $1 == key":" {print; getline; print addr; next}
    {print}
  ' "$CONFIG_PATH" > "$CONFIG_PATH.tmp" && mv "$CONFIG_PATH.tmp" "$CONFIG_PATH"
}

update_config() {
  backup_config

  if [ ! -f "$CONFIG_PATH" ]; then
    write_config_template
    return
  fi

  replace_line '^role: .*' "role: \"$ROLE\""
  replace_line '^  interface: .*' "  interface: \"$IFACE\""
  replace_line '^    addr: .*' "    addr: \"$LOCAL_IP:$PORT\""
  if [ "$ROLE" = "client" ]; then
    replace_line '^    addr: .*' "    addr: \"$LOCAL_IP:0\""
    replace_line '^  - listen: .*' "  - listen: \"127.0.0.1:$SOCKS_PORT\""
    replace_addr_block "server" "$PEER_IP:$PORT"
  else
    replace_addr_block "listen" "0.0.0.0:$PORT"
  fi
  replace_line '^    router_mac: .*' "    router_mac: \"$ROUTER_MAC\""
  replace_line '^    key: .*' "    key: \"$KCP_KEY\""
  if [ -n "$MTU" ]; then
    replace_line '^    mtu: .*' "    mtu: $MTU"
  fi
}

ensure_role() {
  normalize_role
  if [ "$ROLE" != "client" ] && [ "$ROLE" != "server" ]; then
    die "--role client|server is required."
  fi
}

install_action() {
  require_root
  ensure_role
  info "[1/5] Downloading package..."
  ensure_package
  success "Package ready."

  info "[2/5] Preparing configuration files..."
  ensure_custom_files
  success "Configuration files ready."

  if [ ! -x /root/paqet-hub/paqet_linux_amd64 ]; then
    chmod +x /root/paqet-hub/paqet_linux_amd64
  fi
  if [ ! -x /root/paqet-hub/paqet_linux_amd64 ]; then
    die "paqet_linux_amd64 not found in /root/paqet-hub."
  fi
  success "Binary permissions set."

  info "[3/5] Installing systemd service..."
  write_service
  systemctl daemon-reload
  systemctl enable paqet
  success "Service installed."

  info "[4/5] Finalizing..."
  success "Installation complete."
  show_installation_summary
}

configure_action() {
  require_root
  ensure_role

  detect_iface
  detect_local_ip
  detect_router_mac

  validate_config_values

  update_config
  apply_tuning
  systemctl daemon-reload
}

manage_action() {
  require_root
  case "$ACTION" in
    start|stop|restart|status)
      systemctl "$ACTION" paqet
      ;;
    logs)
      journalctl -u paqet -n "$LOG_LINES" -f
      ;;
    test)
      test_connection
      ;;
    view-config)
      view_config_action
      ;;
    backup-config)
      backup_config_action
      ;;
    update-binary)
      update_binary_action
      ;;
    firewall-apply)
      ensure_role
      if [ "$ROLE" != "server" ]; then
        die "firewall-apply is only supported for server role."
      fi
      firewall_apply
      ;;
    firewall-clean)
      ensure_role
      if [ "$ROLE" != "server" ]; then
        die "firewall-clean is only supported for server role."
      fi
      firewall_clean
      ;;
    uninstall)
      uninstall_action
      ;;
    *)
      die "Unknown action: $ACTION"
      ;;
  esac
}

view_config_action() {
  if [ -f "$CONFIG_PATH" ]; then
    echo -e "${BOLD}Config: $CONFIG_PATH${NC}"
    echo "----------------------------------------"
    cat "$CONFIG_PATH"
  else
    warn "Config file not found at $CONFIG_PATH"
  fi
}

backup_config_action() {
  if [ -f "$CONFIG_PATH" ]; then
    backup_config
    success "Backup created for $CONFIG_PATH"
  else
    warn "Config file not found at $CONFIG_PATH"
  fi
}

uninstall_action() {
  systemctl stop paqet || true
  systemctl disable paqet || true
  rm -f "$SERVICE_PATH"
  rm -rf /root/paqet-hub
  rm -f /etc/sysctl.d/99-max-performance.conf
  systemctl daemon-reload

  if [ "$PURGE" = "true" ]; then
    local script_path
    script_path="$(readlink -f "$0" 2>/dev/null || echo "$0")"
    rm -f "$script_path" || true
    if [ -f /usr/local/bin/easyPaqet ] && [ "$script_path" != "/usr/local/bin/easyPaqet" ]; then
      rm -f /usr/local/bin/easyPaqet || true
    fi
  fi
}

run_action() {
  case "$ACTION" in
    quick-install)
      quick_install_guided
      ;;
    install)
      install_action
      if [ "$RUN_CONFIG_AFTER_INSTALL" = "true" ]; then
        configure_action
        if [ "$ROLE" = "server" ]; then
          local apply_fw
          apply_fw="$(prompt_yes_no "Apply firewall rules now? (yes/no)" "yes")"
          if [ "$apply_fw" = "yes" ]; then
            APPLY_FIREWALL_AFTER_CONFIG="true"
          fi
        fi

        local start_now
        start_now="$(prompt_yes_no "Start service now? (yes/no)" "yes")"
        if [ "$start_now" = "yes" ]; then
          START_SERVICE_AFTER_CONFIG="true"
        fi

        if [ "$ROLE" = "client" ]; then
          local test_now
          test_now="$(prompt_yes_no "Test connection now? (yes/no)" "no")"
          if [ "$test_now" = "yes" ]; then
            RUN_TEST_AFTER_CONFIG="true"
          fi
        fi

        run_post_config_actions
      else
        systemctl restart paqet
        sleep 3
        if [ "$ROLE" = "client" ]; then
          test_connection
        fi
      fi
      ;;
    configure)
      configure_action
      run_post_config_actions
      ;;
    start|stop|restart|status|logs|firewall-apply|firewall-clean|uninstall|update-binary|test|view-config|backup-config)
      manage_action
      ;;
    *)
      usage
      exit 1
      ;;
  esac
}

firewall_apply() {
  iptables -t raw -C PREROUTING -p tcp --dport "$PORT" -j NOTRACK 2>/dev/null \
    || iptables -t raw -A PREROUTING -p tcp --dport "$PORT" -j NOTRACK
  iptables -t raw -C OUTPUT -p tcp --sport "$PORT" -j NOTRACK 2>/dev/null \
    || iptables -t raw -A OUTPUT -p tcp --sport "$PORT" -j NOTRACK
  iptables -t mangle -C OUTPUT -p tcp --sport "$PORT" --tcp-flags RST RST -j DROP 2>/dev/null \
    || iptables -t mangle -A OUTPUT -p tcp --sport "$PORT" --tcp-flags RST RST -j DROP
  save_firewall_rules
}

firewall_clean() {
  iptables -t raw -D PREROUTING -p tcp --dport "$PORT" -j NOTRACK 2>/dev/null || true
  iptables -t raw -D OUTPUT -p tcp --sport "$PORT" -j NOTRACK 2>/dev/null || true
  iptables -t mangle -D OUTPUT -p tcp --sport "$PORT" --tcp-flags RST RST -j DROP 2>/dev/null || true
  save_firewall_rules
}

save_firewall_rules() {
  if ! command -v iptables-save >/dev/null 2>&1; then
    return
  fi
  mkdir -p /etc/iptables
  iptables-save > /etc/iptables/rules.v4
}

test_connection() {
  if ! command -v curl >/dev/null 2>&1; then
    warn "curl not found; cannot test connection."
    return
  fi
  echo ""
  info "Testing SOCKS5 connection..."
  echo ""
  local attempt
  for attempt in 1 2 3; do
    echo -ne "  Attempt $attempt/3... "
    if curl -s --max-time 15 https://google.com --proxy "socks5h://127.0.0.1:$SOCKS_PORT" >/dev/null 2>&1; then
      echo -e "${GREEN}OK${NC}"
      echo ""
      success "Connection test passed."
      return
    fi
    echo -e "${RED}FAIL${NC}"
    if [ "$attempt" -lt 3 ]; then
      sleep 2
    fi
  done
  echo ""
  error "Connection test failed after 3 attempts."
  return 1
}

show_installation_summary() {
  echo ""
  success "Installation complete."
  echo ""
  echo -e "${BOLD}Next steps:${NC}"
  if [ "$ROLE" = "server" ]; then
    echo "  1) Share this KCP key with clients:"
    echo -e "     ${CYAN}$KCP_KEY${NC}"
    echo "  2) Apply firewall rules:"
    echo "     sudo $0 firewall-apply --role server --port $PORT"
    echo "  3) Start the service:"
    echo "     sudo systemctl start paqet"
  else
    echo "  1) Start the service:"
    echo "     sudo systemctl start paqet"
    echo "  2) Test the connection:"
    echo "     curl -x socks5h://127.0.0.1:$SOCKS_PORT https://google.com"
  fi
  echo ""
}

update_binary_action() {
  require_root
  local tmp_dir
  tmp_dir="$(make_tmp_dir)"
  if ! download_from_github_latest "$tmp_dir"; then
    rm -rf "$tmp_dir"
    die "GitHub download failed."
  fi

  local file_path
  file_path="$(ls -1 "$tmp_dir" | head -n1)"
  if [ -z "$file_path" ]; then
    rm -rf "$tmp_dir"
    die "Download failed."
  fi

  update_binary_from_archive "$tmp_dir/$file_path"
  rm -rf "$tmp_dir"
  systemctl restart paqet
}

run_post_config_actions() {
  if [ "$APPLY_FIREWALL_AFTER_CONFIG" = "true" ] && [ "$ROLE" = "server" ]; then
    firewall_apply
  fi
  if [ "$START_SERVICE_AFTER_CONFIG" = "true" ]; then
    systemctl start paqet
  fi
  systemctl restart paqet
  sleep 3
  if [ "$ROLE" = "client" ]; then
    test_connection
  elif [ "$RUN_TEST_AFTER_CONFIG" = "true" ]; then
    systemctl status paqet --no-pager
  fi
}

main() {
  init_colors
  parse_args "$@"
  normalize_role
  show_status_badge
  if [ "$INTERACTIVE" = "true" ]; then
    interactive_menu
    return
  fi
  run_action
}

main "$@"
